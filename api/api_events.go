/*
Logistic Tracking service API - DCSA OpenAPI specification for Track & Trace v2.2.0

Managing and sending Shipment-, Transport- and Equipment-events and subscriptions for Track &amp; Trace (T&amp;T). API specification issued by DCSA.org. For explanation to specific values or objects please refer to the <a href='https://dcsa.org/wp-content/uploads/2021/10/202108_DCSA_P1_Information-Model-v3.3_TNT22_Final.pdf'>Information Model v3.3</a> Polling can be done on the <b>GET /events</b> endPoint. DCSA version 2.2.0

API version: 1.0.3
Contact: ho.support-api@cma-cgm.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type EventsApi interface {

	/*
	GetMoveOnCommercialCycle Find Commercial events from unique tracking greference.

	Return commercial cycle belonging to provided tracking reference
<b>Query is not DCSA compliant but Return data follow DCSA TNT 2.2.0 specifications</b>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param trackingReference Shipment reference or Equipment identifier
	@return ApiGetMoveOnCommercialCycleRequest
	*/
	GetMoveOnCommercialCycle(ctx context.Context, trackingReference string) ApiGetMoveOnCommercialCycleRequest

	// GetMoveOnCommercialCycleExecute executes the request
	//  @return []SearchMoveOnCommercialCycle200ResponseInner
	GetMoveOnCommercialCycleExecute(r ApiGetMoveOnCommercialCycleRequest) ([]SearchMoveOnCommercialCycle200ResponseInner, *http.Response, error)

	/*
	SearchMoveOnCommercialCycle Find Commercial events.

	Returns all events filtered by the queryParameters.
<b>NB</b>&#58; It is possible to combine queryParameters. When combining queryParameters be aware that it is also possible to make combinations that are mutual contradicting.
Example&#58; <i>shipmentEventTypeCode=DRFT and equipmentEventTypeCode=GTIN</i>
Since there is no event that can be a ShipmentEvent <u>and</u> an EquipmentEvent at the same time <b>this will return an empty list</b>!
<b>Follow DCSA TNT 2.2.0 specifications</b>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchMoveOnCommercialCycleRequest
	*/
	SearchMoveOnCommercialCycle(ctx context.Context) ApiSearchMoveOnCommercialCycleRequest

	// SearchMoveOnCommercialCycleExecute executes the request
	//  @return []SearchMoveOnCommercialCycle200ResponseInner
	SearchMoveOnCommercialCycleExecute(r ApiSearchMoveOnCommercialCycleRequest) ([]SearchMoveOnCommercialCycle200ResponseInner, *http.Response, error)
}

// EventsApiService EventsApi service
type EventsApiService service

type ApiGetMoveOnCommercialCycleRequest struct {
	ctx context.Context
	ApiService EventsApi
	trackingReference string
	behalfOf *string
}

// (Mandatory if you are a Third Party). This field specifies the end customer code you request a rate for. Use our referential API Partner to check if the end customer exists and to get its Partner ID code
func (r ApiGetMoveOnCommercialCycleRequest) BehalfOf(behalfOf string) ApiGetMoveOnCommercialCycleRequest {
	r.behalfOf = &behalfOf
	return r
}

func (r ApiGetMoveOnCommercialCycleRequest) Execute() ([]SearchMoveOnCommercialCycle200ResponseInner, *http.Response, error) {
	return r.ApiService.GetMoveOnCommercialCycleExecute(r)
}

/*
GetMoveOnCommercialCycle Find Commercial events from unique tracking greference.

Return commercial cycle belonging to provided tracking reference
<b>Query is not DCSA compliant but Return data follow DCSA TNT 2.2.0 specifications</b>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingReference Shipment reference or Equipment identifier
 @return ApiGetMoveOnCommercialCycleRequest
*/
func (a *EventsApiService) GetMoveOnCommercialCycle(ctx context.Context, trackingReference string) ApiGetMoveOnCommercialCycleRequest {
	return ApiGetMoveOnCommercialCycleRequest{
		ApiService: a,
		ctx: ctx,
		trackingReference: trackingReference,
	}
}

// Execute executes the request
//  @return []SearchMoveOnCommercialCycle200ResponseInner
func (a *EventsApiService) GetMoveOnCommercialCycleExecute(r ApiGetMoveOnCommercialCycleRequest) ([]SearchMoveOnCommercialCycle200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SearchMoveOnCommercialCycle200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.GetMoveOnCommercialCycle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/{trackingReference}"
	localVarPath = strings.Replace(localVarPath, "{"+"trackingReference"+"}", url.PathEscape(parameterToString(r.trackingReference, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.behalfOf != nil {
		localVarQueryParams.Add("behalfOf", parameterToString(*r.behalfOf, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["keyId"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v InlineResponseDefault
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchMoveOnCommercialCycleRequest struct {
	ctx context.Context
	ApiService EventsApi
	eventType *[]string
	shipmentEventTypeCode *[]ShipmentEventTypeCode
	documentTypeCode *[]DocumentTypeCode
	carrierBookingReference *string
	transportDocumentReference *string
	transportEventTypeCode *[]TransportEventTypeCode
	transportCallID *string
	vesselIMONumber *string
	exportVoyageNumber *string
	carrierServiceCode *string
	uNLocationCode *string
	equipmentEventTypeCode *[]EquipmentEventTypeCode
	equipmentReference *string
	eventCreatedDateTime *time.Time
	behalfOf *string
}

// The type of event(s) to filter by. Possible values are - SHIPMENT (Shipment events) - TRANSPORT (Transport events) - EQUIPMENT (Equipment events) It is possible to select multiple values by comma (,) separating them. For multiple values the OR-operator is used. For example eventType&#x3D;SHIPMENT,EQUIPMENT matches both Shipment- and Equipment-events. Default value is all event types.
func (r ApiSearchMoveOnCommercialCycleRequest) EventType(eventType []string) ApiSearchMoveOnCommercialCycleRequest {
	r.eventType = &eventType
	return r
}

// The status of the document in the process to filter by. Possible values are - RECE (Received) - DRFT (Drafted) - PENA (Pending Approval) - PENU (Pending Update) - REJE (Rejected) - APPR (Approved) - ISSU (Issued) - SURR (Surrendered) - SUBM (Submitted) - VOID (Void) - CONF (Confirmed) - REQS (Requested) - CMPL (Completed) - HOLD (On Hold) - RELS (Released) It is possible to select multiple values by comma (,) separating them. For multiple values the OR-operator is used. For example &lt;i&gt;shipmentEventTypeCode&#x3D;RECE,DRFT&lt;/i&gt;  Matches &lt;b&gt;both&lt;/b&gt; Received (RECE) and Drafted (DRFT) shipment events. Default is all shipmentEventTypeCodes. This filter is only relevant when filtering on ShipmentEvents
func (r ApiSearchMoveOnCommercialCycleRequest) ShipmentEventTypeCode(shipmentEventTypeCode []ShipmentEventTypeCode) ApiSearchMoveOnCommercialCycleRequest {
	r.shipmentEventTypeCode = &shipmentEventTypeCode
	return r
}

// The documentTypeCode to filter by. Possible values are - CBR (Carrier Booking Request Reference) - BKG (Booking) - SHI (Shipping Instruction) - SRM (Shipment Release Message) - TRD (Transport Document) - ARN (Arrival Notice) - VGM (Verified Gross Mass) - CAS (Cargo Survey) - CUS (Customs Inspection) - DGD (Dangerous Goods Declaration) - OOG (Out of Gauge) It is possible to select multiple values by comma (,) separating them. For multiple values the OR-operator is used. For example &lt;i&gt;documentTypeCode&#x3D;SHI,TRD&lt;/i&gt; Matches &lt;b&gt;both&lt;/b&gt; ShippingInstruction (SHI) and TransportDocument (TRD) shipment events. Default is all documentTypeCodes. This filter is only relevant when filtering on ShipmentEvents
func (r ApiSearchMoveOnCommercialCycleRequest) DocumentTypeCode(documentTypeCode []DocumentTypeCode) ApiSearchMoveOnCommercialCycleRequest {
	r.documentTypeCode = &documentTypeCode
	return r
}

// A set of unique characters provided by carrier to identify a booking. Specifying this filter will only return events related to this particular carrierBookingReference.
func (r ApiSearchMoveOnCommercialCycleRequest) CarrierBookingReference(carrierBookingReference string) ApiSearchMoveOnCommercialCycleRequest {
	r.carrierBookingReference = &carrierBookingReference
	return r
}

// A unique number reference allocated by the shipping line to the transport document and the main number used for the tracking of the status of the shipment. Specifying this filter will only return events related to this particular transportDocumentReference
func (r ApiSearchMoveOnCommercialCycleRequest) TransportDocumentReference(transportDocumentReference string) ApiSearchMoveOnCommercialCycleRequest {
	r.transportDocumentReference = &transportDocumentReference
	return r
}

// Identifier for type of Transport event to filter by - ARRI (Arrived) - DEPA (Departed) It is possible to select multiple values by comma (,) separating them. For multiple values the OR-operator is used. For example &lt;i&gt;transportEventTypeCode&#x3D;ARRI,DEPA&lt;/i&gt; matches &lt;b&gt;both&lt;/b&gt; Arrived (ARRI) and Departed (DEPA) transport events. Default is all transportEventTypeCodes. This filter is only relevant when filtering on TransportEvents
func (r ApiSearchMoveOnCommercialCycleRequest) TransportEventTypeCode(transportEventTypeCode []TransportEventTypeCode) ApiSearchMoveOnCommercialCycleRequest {
	r.transportEventTypeCode = &transportEventTypeCode
	return r
}

// ID uniquely identifying a transport call, to filter events by. Specifying this filter will only return events related to this particular transportCallID
func (r ApiSearchMoveOnCommercialCycleRequest) TransportCallID(transportCallID string) ApiSearchMoveOnCommercialCycleRequest {
	r.transportCallID = &transportCallID
	return r
}

// The identifier of vessel for which schedule details are published. Depending on schedule type, this may not be available yet. Specifying this filter will only return events related to this particular vesselIMONumber.
func (r ApiSearchMoveOnCommercialCycleRequest) VesselIMONumber(vesselIMONumber string) ApiSearchMoveOnCommercialCycleRequest {
	r.vesselIMONumber = &vesselIMONumber
	return r
}

// Filter on the vessel operator-specific identifier of the export Voyage. Specifying this filter will only return events related to this particular exportVoyageNumber.
func (r ApiSearchMoveOnCommercialCycleRequest) ExportVoyageNumber(exportVoyageNumber string) ApiSearchMoveOnCommercialCycleRequest {
	r.exportVoyageNumber = &exportVoyageNumber
	return r
}

// Filter on the carrier specific identifier of the service. Specifying this filter will only return events related to this particular carrierServiceCode.
func (r ApiSearchMoveOnCommercialCycleRequest) CarrierServiceCode(carrierServiceCode string) ApiSearchMoveOnCommercialCycleRequest {
	r.carrierServiceCode = &carrierServiceCode
	return r
}

// The UN Location code specifying where the place is located. Specifying this filter will only return events related to this particular UN Location code.
func (r ApiSearchMoveOnCommercialCycleRequest) UNLocationCode(uNLocationCode string) ApiSearchMoveOnCommercialCycleRequest {
	r.uNLocationCode = &uNLocationCode
	return r
}

// Unique identifier for equipmentEventTypeCode. - LOAD (Loaded) - DISC (Discharged) - GTIN (Gated in) - GTOT (Gated out) - STUF (Stuffed) - STRP (Stripped) - PICK (Pick-up) - DROP (Drop-off) - INSP (Inspected) - RSEA (Resealed) - RMVD (Removed) It is possible to select multiple values by comma (,) separating them. For multiple values the OR-operator is used. For example &lt;i&gt;equipmentEventTypeCode&#x3D;GTIN,GTOT&lt;/i&gt; matches &lt;b&gt;both&lt;/b&gt; Gated in (GTIN) and Gated out (GTOT) equipment events. Default is all equipmentEventTypeCodes. This filter is only relevant when filtering on EquipmentEvents
func (r ApiSearchMoveOnCommercialCycleRequest) EquipmentEventTypeCode(equipmentEventTypeCode []EquipmentEventTypeCode) ApiSearchMoveOnCommercialCycleRequest {
	r.equipmentEventTypeCode = &equipmentEventTypeCode
	return r
}

// Will filter by the unique identifier for the equipment, which should follow the BIC ISO Container Identification Number where possible. Specifying this filter will only return events related to this particular equipmentReference
func (r ApiSearchMoveOnCommercialCycleRequest) EquipmentReference(equipmentReference string) ApiSearchMoveOnCommercialCycleRequest {
	r.equipmentReference = &equipmentReference
	return r
}

// Limit the result based on the creating date of the event. It is possible to use operators on this query parameter. This is done by adding a colon followed by an operator at the end of the queryParameterName (before the &#x3D;) &lt;i&gt;eventCreatedDateTime&lt;b&gt;&amp;#58;gte&lt;/b&gt;&#x3D;2021-04-01T14&amp;#58;12&amp;#58;56+01&amp;#58;00&lt;/i&gt; would result in all events created &amp;#8805; 2021-04-01T14&amp;#58;12&amp;#58;56+01&amp;#58;00 The following operators are supported - &amp;#58;gte (&amp;#8805; Greater than or equal) - &amp;#58;gt (&amp;#62; Greater than) - &amp;#58;lte (&amp;#8804; Less than or equal) - &amp;#58;lt (&amp;#60; Less than) - &amp;#58;eq (&amp;#61; Equal to) If no operator is provided, a &lt;b&gt;strictly equal&lt;/b&gt; is used (this is equivalent to &lt;b&gt;&amp;#58;eq&lt;/b&gt; operator).
func (r ApiSearchMoveOnCommercialCycleRequest) EventCreatedDateTime(eventCreatedDateTime time.Time) ApiSearchMoveOnCommercialCycleRequest {
	r.eventCreatedDateTime = &eventCreatedDateTime
	return r
}

// (Mandatory if you are a Third Party). This field specifies the end customer code you request a rate for. Use our referential API Partner to check if the end customer exists and to get its Partner ID code -- Not a standard DCSA attribute
func (r ApiSearchMoveOnCommercialCycleRequest) BehalfOf(behalfOf string) ApiSearchMoveOnCommercialCycleRequest {
	r.behalfOf = &behalfOf
	return r
}

func (r ApiSearchMoveOnCommercialCycleRequest) Execute() ([]SearchMoveOnCommercialCycle200ResponseInner, *http.Response, error) {
	return r.ApiService.SearchMoveOnCommercialCycleExecute(r)
}

/*
SearchMoveOnCommercialCycle Find Commercial events.

Returns all events filtered by the queryParameters.
<b>NB</b>&#58; It is possible to combine queryParameters. When combining queryParameters be aware that it is also possible to make combinations that are mutual contradicting.
Example&#58; <i>shipmentEventTypeCode=DRFT and equipmentEventTypeCode=GTIN</i>
Since there is no event that can be a ShipmentEvent <u>and</u> an EquipmentEvent at the same time <b>this will return an empty list</b>!
<b>Follow DCSA TNT 2.2.0 specifications</b>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchMoveOnCommercialCycleRequest
*/
func (a *EventsApiService) SearchMoveOnCommercialCycle(ctx context.Context) ApiSearchMoveOnCommercialCycleRequest {
	return ApiSearchMoveOnCommercialCycleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SearchMoveOnCommercialCycle200ResponseInner
func (a *EventsApiService) SearchMoveOnCommercialCycleExecute(r ApiSearchMoveOnCommercialCycleRequest) ([]SearchMoveOnCommercialCycle200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SearchMoveOnCommercialCycle200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.SearchMoveOnCommercialCycle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventType != nil {
		localVarQueryParams.Add("eventType", parameterToString(*r.eventType, "csv"))
	}
	if r.shipmentEventTypeCode != nil {
		localVarQueryParams.Add("shipmentEventTypeCode", parameterToString(*r.shipmentEventTypeCode, "csv"))
	}
	if r.documentTypeCode != nil {
		localVarQueryParams.Add("documentTypeCode", parameterToString(*r.documentTypeCode, "csv"))
	}
	if r.carrierBookingReference != nil {
		localVarQueryParams.Add("carrierBookingReference", parameterToString(*r.carrierBookingReference, ""))
	}
	if r.transportDocumentReference != nil {
		localVarQueryParams.Add("transportDocumentReference", parameterToString(*r.transportDocumentReference, ""))
	}
	if r.transportEventTypeCode != nil {
		localVarQueryParams.Add("transportEventTypeCode", parameterToString(*r.transportEventTypeCode, "csv"))
	}
	if r.transportCallID != nil {
		localVarQueryParams.Add("transportCallID", parameterToString(*r.transportCallID, ""))
	}
	if r.vesselIMONumber != nil {
		localVarQueryParams.Add("vesselIMONumber", parameterToString(*r.vesselIMONumber, ""))
	}
	if r.exportVoyageNumber != nil {
		localVarQueryParams.Add("exportVoyageNumber", parameterToString(*r.exportVoyageNumber, ""))
	}
	if r.carrierServiceCode != nil {
		localVarQueryParams.Add("carrierServiceCode", parameterToString(*r.carrierServiceCode, ""))
	}
	if r.uNLocationCode != nil {
		localVarQueryParams.Add("UNLocationCode", parameterToString(*r.uNLocationCode, ""))
	}
	if r.equipmentEventTypeCode != nil {
		localVarQueryParams.Add("equipmentEventTypeCode", parameterToString(*r.equipmentEventTypeCode, "csv"))
	}
	if r.equipmentReference != nil {
		localVarQueryParams.Add("equipmentReference", parameterToString(*r.equipmentReference, ""))
	}
	if r.eventCreatedDateTime != nil {
		localVarQueryParams.Add("eventCreatedDateTime", parameterToString(*r.eventCreatedDateTime, ""))
	}
	if r.behalfOf != nil {
		localVarQueryParams.Add("behalfOf", parameterToString(*r.behalfOf, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["keyId"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v InlineResponseDefault
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
